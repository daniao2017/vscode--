## C/C++堆和栈的区别
参考链接[C/C++堆和栈的区别](https://www.cnblogs.com/shilipojianshen/p/13584451.html)

- 管理方式不同
堆：产生和释放由程序员控制。
栈，由编译器自动管理，无需程序员手工控制；

- 空间大小不同

堆内存可以达到4G。栈的空间有限；

- 能否产生碎片不同

堆则容易产生碎片，多次的new/delete会造成内存的不连续，从而造成大量的碎片。

栈不会产生碎片，因为栈是种先进后出的队列。

- 生长方向不同

堆的生长方式是向上的，栈是向下的。

- 分配方式不同

堆是动态分配的。栈可以是静态分配和动态分配两种，但是栈的动态分配由编译器释放。

- 分配效率不同

栈是机器系统提供的数据结构，计算机底层对栈提供支持：分配专门的寄存器存放栈的地址，压栈出栈都有专门的指令。堆则是由C/C++函数库提供，库函数会按照一定的算法在堆内存中搜索可用的足够大小的空间，如果没有足够大小的空间（可能是由于内存碎片太多），就有可能调用系统功能去增加程序数据段的内存空间，这样就有机会分到足够大小的内存，然后进行返回。显然，堆的效率比栈要低得多。

堆和栈相比，由于大量new/delete的使用，容易造成大量的内存碎片；由于没有专门的系统支持，效率很低；由于可能引发用户态和核心态的切换，内存的申请，代价变得更加昂贵。所以栈在程序中是应用最广泛的，就算是函数的调用也利用栈去完成，函数调用过程中的参数，返回地址，EBP和局部变量都采用栈的方式存放。所以，我们推荐大家  尽量用栈，而不是用堆。

具体实践可以参考
[c/c++的堆与栈 与数据结构的堆和栈的区别](https://blog.csdn.net/u011939264/article/details/52861033)

## 回文数
>判断一个整数是否是回文数。回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。

参考实现
```
bool isPalindrome(int x){
    long sum=0;
    int m=x;
    if (x<0){
        return false;
    }
    while (x>0){
        sum=sum*10+x%10;
        x/=10;
    }
    if (sum==m){
        return true;
    }else{
        return false;
    }
}
作者：rain-sure
链接：https://leetcode-cn.com/problems/palindrome-number/solution/hui-wen-shu-cyu-yan-shi-xian-by-rain-sure/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```
